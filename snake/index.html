<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snakely</title>

  <style>
    /*================================================
    General
    ================================================*/
    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      font-family: sans-serif;
      overflow: hidden;
      background: radial-gradient(#333, #111);
      display: flex;
      justify-content: center;
      align-items: center;
      color: #fff;
    }

    /*================================================
    Score
    ================================================*/
    .score {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-weight: bold;
      font-size: 18px;
      color: rgba(255, 255, 255, 0.7);
      z-index: 10;
    }

    /*================================================
    Stage
    ================================================*/
    .stage {
      position: relative;
      z-index: 1;
    }

    /*================================================
    Tiles
    ================================================*/
    .tile {
      position: absolute;
      background: rgba(255, 255, 255, 0.1);
      transition: background 0.3s, box-shadow 0.3s, transform 0.3s, opacity 0.3s;
      transform: translateZ(0);
    }

    .tile.pressed {
      background: rgba(255, 255, 255, 0.3);
      box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.5);
    }

    /*================================================
    Pause Menu
    ================================================*/
    #pauseMenu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      border: 2px solid #fff;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      display: none;
      z-index: 20;
    }

    #pauseMenu h2 {
      margin-top: 0;
      margin-bottom: 15px;
    }

    #pauseMenu select, #pauseMenu input, #pauseMenu button {
      margin: 5px 0;
      padding: 5px 10px;
      font-size: 16px;
    }

    #pauseMenu button {
      cursor: pointer;
      background: #00ff00;
      border: none;
      border-radius: 5px;
      color: #000;
      font-weight: bold;
    }

    #pauseMenu button:hover {
      background: #0f0;
    }
  </style>
</head>
<body>

  <!-- Score -->
  <div class="score">0</div>

  <!-- Stage -->
  <div class="stage"></div>

  <!-- Menu de pausa -->
  <div id="pauseMenu">
    <h2>Menu</h2>

    <label for="gameMode">Modo de jogo:</label><br>
    <select id="gameMode">
      <option value="normal">Normal</option>
      <option value="arcade">Arcade (1 min)</option>
    </select><br>

    <label for="difficulty">Dificuldade:</label><br>
    <select id="difficulty">
      <option value="easy">Fácil</option>
      <option value="normal" selected>Normal</option>
      <option value="hard">Difícil</option>
    </select><br>

    <label for="snakeColor">Cor da Cobra:</label><br>
    <input type="color" id="snakeColor" value="#00ff00"><br>

    <button id="resumeBtn">Iniciar / Continuar</button>
  </div>

  <!-- Sons -->
  <audio id="eatSound" src="eat.mp3"></audio>
  <audio id="gameOverSound" src="gameover.mp3"></audio>
<script>
/*================================================
 Polyfill
 ================================================*/
(function(){ 'use strict';
var lastTime = 0;
var vendors = [ 'webkit', 'moz' ];
for( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
    window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
    window.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];
}
if( !window.requestAnimationFrame ) {
    window.requestAnimationFrame = function( callback, element ) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
        var id = window.setTimeout(function(){ callback(currTime + timeToCall); }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    }
}
if( !window.cancelAnimationFrame ) {
    window.cancelAnimationFrame = function( id ) { clearTimeout(id); }
}
})();

/*================================================
 DOM Manipulation
 ================================================*/
(function(){ 'use strict';
function hasClass(elem, className){ return new RegExp(' '+className+' ').test(' '+elem.className+' '); }
function addClass(elem, className){ if(!hasClass(elem, className)) elem.className += ' '+className; }
function removeClass(elem, className){
    var newClass = ' ' + elem.className.replace(/[\t\r\n]/g,' ') + ' ';
    if(hasClass(elem,className)){
        while(newClass.indexOf(' '+className+' ')>=0) newClass = newClass.replace(' '+className+' ',' ');
        elem.className = newClass.replace(/^\s+|\s+$/g,'');
    }
}
function toggleClass(elem,className){
    if(hasClass(elem,className)) removeClass(elem,className);
    else addClass(elem,className);
}
})();

/*================================================
 Core & Utilities
 ================================================*/
g = {};
(function(){ 'use strict';
g.m = Math;
g.mathProps = 'E LN10 LN2 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos asin atan ceil cos exp floor log round sin sqrt tan atan2 pow max min'.split(' ');
for(var i=0;i<g.mathProps.length;i++){ g[g.mathProps[i]]=g.m[g.mathProps[i]]; }
g.m.TWO_PI = g.m.PI*2;
g.isset = function(prop){ return typeof prop!='undefined'; };
g.log = function(){
    if(g.isset(g.config) && g.config.debug && window.console){ console.log(Array.prototype.slice.call(arguments)); }
};
g.util = {};
g.util.rand = function(min,max){ return g.m.random()*(max-min)+min; };
g.util.randInt = function(min,max){ return g.m.floor(g.m.random()*(max-min+1))+min; };
})();

/*================================================
 State & Group
 ================================================*/
(function(){ 'use strict';
g.Group = function(){ this.collection=[]; this.length=0; };
g.Group.prototype.add=function(item){ this.collection.push(item); this.length++; };
g.Group.prototype.remove=function(index){ if(index<this.length){ this.collection.splice(index,1); this.length--; } };
g.Group.prototype.empty=function(){ this.collection.length=0; this.length=0; };
g.Group.prototype.each=function(action,asc){ var asc=asc||0,i;if(asc){ for(i=0;i<this.length;i++) this.collection[i][action](i); } else{ i=this.length; while(i--) this.collection[i][action](i); } };
g.states = {};
g.addState=function(state){ g.states[state.name]=state; };
g.setState=function(name){ if(g.state) g.states[g.state].exit(); g.state=name; g.states[g.state].init(); };
g.currentState=function(){ return g.states[g.state]; };
})();

/*================================================
 Time
 ================================================*/
(function(){ 'use strict';
g.Time=function(){ this.reset(); };
g.Time.prototype.reset=function(){ this.now=Date.now(); this.last=Date.now(); this.delta=60; this.ndelta=1; this.elapsed=0; this.nelapsed=0; this.tick=0; };
g.Time.prototype.update=function(){ this.now=Date.now(); this.delta=this.now-this.last; this.ndelta=Math.min(Math.max(this.delta/(1000/60),0.0001),10); this.elapsed+=this.delta; this.nelapsed+=this.ndelta; this.last=this.now; this.tick++; };
})();

        /*================================================
        Grid Entity
        ================================================*/
        (function(){ 'use strict';

        g.Grid = function( cols, rows ) {
            this.cols = cols;
            this.rows = rows;
            this.tiles = [];
            for( var x = 0; x < cols; x++ ) {
            this.tiles[ x ] = [];
            for( var y = 0; y < rows; y++ ) {
                this.tiles[ x ].push( 'empty' );
            }
            }
        };

        g.Grid.prototype.get = function( x, y ) {
            return this.tiles[ x ][ y ];
        };

        g.Grid.prototype.set = function( x, y, val ) {
            this.tiles[ x ][ y ] = val;
        };

        })();

        /*================================================
        Board Tile Entity
        ================================================*/
        (function(){ 'use strict';

        g.BoardTile = function( opt ) {
            this.parentState = opt.parentState;
            this.parentGroup = opt.parentGroup;
            this.col = opt.col;
            this.row = opt.row;
            this.x = opt.x;
            this.y = opt.y;
            this.z = 0;
            this.w = opt.w;
            this.h = opt.h;
            this.elem = document.createElement( 'div' );
            this.elem.style.position = 'absolute';
            this.elem.className = 'tile';
            this.parentState.stageElem.appendChild( this.elem );
            this.classes = {
            pressed: 0,
            path: 0,
            up: 0,
            down: 0,
            left: 0,
            right: 0
            }
            this.updateDimensions();
        };

        g.BoardTile.prototype.update = function() {
            for( var k in this.classes ) {
            if( this.classes[ k ] ) {
                this.classes[ k ]--;
            }
            }

            if( this.parentState.food.tile.col == this.col || this.parentState.food.tile.row == this.row ) {
            this.classes.path = 1;
            if( this.col < this.parentState.food.tile.col ) {
                this.classes.right = 1;
            } else {
                this.classes.right = 0;
            }
            if( this.col > this.parentState.food.tile.col ) {
                this.classes.left = 1;
            } else {
                this.classes.left = 0;
            }
            if( this.row > this.parentState.food.tile.row ) {
                this.classes.up = 1;
            } else {
                this.classes.up = 0;
            }
            if( this.row < this.parentState.food.tile.row ) {
                this.classes.down = 1;
            } else {
                this.classes.down = 0;
            }
            } else {
            this.classes.path = 0;
            }

            if( this.parentState.food.eaten ) {
            this.classes.path = 0;
            }
        };

        g.BoardTile.prototype.updateDimensions = function() {
            this.x = this.col * this.parentState.tileWidth;
            this.y = this.row * this.parentState.tileHeight;
            this.w = this.parentState.tileWidth - this.parentState.spacing;
            this.h = this.parentState.tileHeight - this.parentState.spacing;
            this.elem.style.left = this.x + 'px';
            this.elem.style.top = this.y + 'px';
            this.elem.style.width = this.w + 'px';
            this.elem.style.height = this.h + 'px';
        };

        g.BoardTile.prototype.render = function() {
            var classString = '';
            for( var k in this.classes ) {
            if( this.classes[ k ] ) {
                classString += k + ' ';
            }
            }
            this.elem.className = 'tile ' + classString;
        };

        })();

        /*================================================
        Snake Tile Entity
        ================================================*/
        (function(){ 'use strict';

        g.SnakeTile = function( opt ) {
            this.parentState = opt.parentState;
            this.parentGroup = opt.parentGroup;
            this.col = opt.col;
            this.row = opt.row;
            this.x = opt.x;
            this.y = opt.y;
            this.w = opt.w;
            this.h = opt.h;
            this.color = null;
            this.scale = 1;
            this.rotation = 0;
            this.blur = 0;
            this.alpha = 1;
            this.borderRadius = 0;
            this.borderRadiusAmount = 0;
            this.elem = document.createElement( 'div' );
            this.elem.style.position = 'absolute';
            this.parentState.stageElem.appendChild( this.elem );
        };

        g.SnakeTile.prototype.update = function( i ) {
            this.x = this.col * this.parentState.tileWidth;
            this.y = this.row * this.parentState.tileHeight;
            if( i == 0 ) {
            this.color = '#fff';
            this.blur = this.parentState.dimAvg * 0.03 + Math.sin( this.parentState.time.elapsed / 200 ) * this.parentState.dimAvg * 0.015;
            if( this.parentState.snake.dir == 'n' ) {
                this.borderRadius = this.borderRadiusAmount + '% ' + this.borderRadiusAmount + '% 0 0';
            } else if( this.parentState.snake.dir == 's' ) {
                this.borderRadius = '0 0 ' + this.borderRadiusAmount + '% ' + this.borderRadiusAmount + '%';
            } else if( this.parentState.snake.dir == 'e' ) {
                this.borderRadius = '0 ' + this.borderRadiusAmount + '% ' + this.borderRadiusAmount + '% 0';
            } else if( this.parentState.snake.dir == 'w' ) {
                this.borderRadius = this.borderRadiusAmount + '% 0 0 ' + this.borderRadiusAmount + '%';
            }
            } else {
            this.color = '#fff';
            this.blur = 0;
            this.borderRadius = '0';
            }
            this.alpha = 1 - ( i / this.parentState.snake.tiles.length ) * 0.6;
            this.rotation = ( this.parentState.snake.justAteTick / this.parentState.snake.justAteTickMax ) * 90;
            this.scale = 1 + ( this.parentState.snake.justAteTick / this.parentState.snake.justAteTickMax ) * 1;
        };

        g.SnakeTile.prototype.updateDimensions = function() {
            this.w = this.parentState.tileWidth - this.parentState.spacing;
            this.h = this.parentState.tileHeight - this.parentState.spacing;
        };

        g.SnakeTile.prototype.render = function( i ) {
            this.elem.style.left = this.x + 'px';
            this.elem.style.top = this.y + 'px';
            this.elem.style.width = this.w + 'px';
            this.elem.style.height = this.h + 'px';
            this.elem.style.backgroundColor = 'rgba(255, 255, 255, ' + this.alpha + ')';
            this.elem.style.boxShadow = '0 0 ' + this.blur + 'px #fff';
            this.elem.style.borderRadius = this.borderRadius;
        };

        })();

        /*================================================
        Food Tile Entity
        ================================================*/
        (function(){ 'use strict';

        g.FoodTile = function( opt ) {
            this.parentState = opt.parentState;
            this.parentGroup = opt.parentGroup;
            this.col = opt.col;
            this.row = opt.row;
            this.x = opt.x;
            this.y = opt.y;
            this.w = opt.w;
            this.h = opt.h;
            this.blur = 0;
            this.scale = 1;
            this.hue = 100;
            this.opacity = 0;
            this.elem = document.createElement( 'div' );
            this.elem.style.position = 'absolute';
            this.parentState.stageElem.appendChild( this.elem );
        };

        g.FoodTile.prototype.update = function() {
            this.x = this.col * this.parentState.tileWidth;
            this.y = this.row * this.parentState.tileHeight;
            this.blur = this.parentState.dimAvg * 0.03 + Math.sin( this.parentState.time.elapsed / 200 ) * this.parentState.dimAvg * 0.015;
            this.scale = 0.8 + Math.sin( this.parentState.time.elapsed / 200 ) * 0.2;

            if( this.parentState.food.birthTick || this.parentState.food.deathTick ) {
            if( this.parentState.food.birthTick ) {
                this.opacity = 1 - ( this.parentState.food.birthTick / 1 ) * 1;
            } else {
                this.opacity = ( this.parentState.food.deathTick / 1 ) * 1;
            }
            } else {
            this.opacity = 1;
            }
        };

        g.FoodTile.prototype.updateDimensions = function() {
            this.w = this.parentState.tileWidth - this.parentState.spacing;
            this.h = this.parentState.tileHeight - this.parentState.spacing;
        };

        g.FoodTile.prototype.render = function() {
            this.elem.style.left = this.x + 'px';
            this.elem.style.top = this.y + 'px';
            this.elem.style.width = this.w + 'px';
            this.elem.style.height = this.h + 'px';
            this.elem.style[ 'transform' ] = 'translateZ(0) scale(' + this.scale + ')';
            this.elem.style.backgroundColor = 'hsla(' + this.hue + ', 100%, 60%, 1)';
            this.elem.style.boxShadow = '0 0 ' + this.blur + 'px hsla(' + this.hue + ', 100%, 60%, 1)';
            this.elem.style.opacity = this.opacity;
        };

        })();

/*================================================
 Snake & Food Entities with Pausa, Sons e Menu
 ================================================*/
(function(){ 'use strict';

const pauseMenu = document.getElementById("pauseMenu");
const gameModeSelect = document.getElementById("gameMode");
const difficultySelect = document.getElementById("difficulty");
const snakeColorInput = document.getElementById("snakeColor");
const resumeBtn = document.getElementById("resumeBtn");
const eatSound = document.getElementById("eatSound");
const gameOverSound = document.getElementById("gameOverSound");

let paused = false;
let gameMode = "normal";
let difficulty = "normal";
let snakeColor = "#ffffff";
let arcadeTimer;

document.addEventListener("keydown", e=>{
    if(e.key==="Escape"){
        paused=!paused;
        pauseMenu.style.display=paused?"block":"none";
    }
});

resumeBtn.addEventListener("click", ()=>{
    gameMode = gameModeSelect.value;
    difficulty = difficultySelect.value;
    snakeColor = snakeColorInput.value;

    if(difficulty==="easy") g.currentState().snake.updateTickMax=15;
    if(difficulty==="normal") g.currentState().snake.updateTickMax=10;
    if(difficulty==="hard") g.currentState().snake.updateTickMax=5;

    if(gameMode==="arcade"){
        clearTimeout(arcadeTimer);
        arcadeTimer=setTimeout(()=>{
            alert("⏰ Tempo esgotado! Pontuação: "+g.currentState().score);
            gameOverSound.play();
            g.setState("play");
        },60000);
    }

    pauseMenu.style.display="none";
    paused=false;
});

// Wrapper unificado do update da cobra
const oldSnakeUpdate = g.Snake.prototype.update;
g.Snake.prototype.update=function(){
    if(!paused){
        const prevScore=this.parentState.score;
        oldSnakeUpdate.call(this);
        if(this.parentState.score>prevScore) eatSound.play();
        if(this.deathFlag) gameOverSound.play();
    }
};

// Altera cor da cobra
const oldSnakeTileRender = g.SnakeTile.prototype.render;
g.SnakeTile.prototype.render=function(i){
    this.elem.style.backgroundColor=(i===0)?snakeColor:snakeColor;
    oldSnakeTileRender.call(this,i);
};

})();

        /*================================================
        Play State
        ================================================*/
        (function(){ 'use strict';

        function StatePlay() {
            this.name = 'play';
        }

        StatePlay.prototype.init = function() {
            this.scoreElem = document.querySelector( '.score' );
            this.stageElem = document.querySelector( '.stage' );
            this.dimLong = 28;
            this.dimShort = 16;
            this.padding = 0.25;
            this.boardTiles = new g.Group();
            this.keys = {};
            this.foodCreateTimeout = null;
            this.score = 0;
            this.scoreElem.innerHTML = this.score;
            this.time = new g.Time();
            this.getDimensions();
            if( this.winWidth < this.winHeight ) {
            this.rows = this.dimLong;
            this.cols = this.dimShort;
            } else {
            this.rows = this.dimShort;
            this.cols = this.dimLong;
            }
            this.spacing = 1;
            this.grid = new g.Grid( this.cols, this.rows );
            this.resize();
            this.createBoardTiles();
            this.bindEvents();
            this.snake = new g.Snake({
            parentState: this
            });
            this.food = new g.Food({
            parentState: this
            });
        };

        StatePlay.prototype.getDimensions = function() {
            this.winWidth = window.innerWidth;
            this.winHeight = window.innerHeight;
            this.activeWidth = this.winWidth - ( this.winWidth * this.padding );
            this.activeHeight = this.winHeight - ( this.winHeight * this.padding );
        };

        StatePlay.prototype.resize = function() {
            var _this = g.currentState();

            _this.getDimensions();

            _this.stageRatio = _this.rows / _this.cols;

            if( _this.activeWidth > _this.activeHeight / _this.stageRatio ) {
            _this.stageHeight = _this.activeHeight;
            _this.stageElem.style.height = _this.stageHeight + 'px';
            _this.stageWidth = Math.floor( _this.stageHeight /_this.stageRatio );
            _this.stageElem.style.width = _this.stageWidth + 'px';
            } else {
            _this.stageWidth = _this.activeWidth;
            _this.stageElem.style.width = _this.stageWidth + 'px';
            _this.stageHeight = Math.floor( _this.stageWidth * _this.stageRatio );
            _this.stageElem.style.height = _this.stageHeight + 'px';
            }

            _this.tileWidth = ~~( _this.stageWidth / _this.cols );
            _this.tileHeight = ~~( _this.stageHeight / _this.rows );
            _this.dimAvg = ( _this.activeWidth + _this.activeHeight ) / 2;
            _this.spacing = Math.max( 1, ~~( _this.dimAvg * 0.0025 ) );

            _this.stageElem.style.marginTop = ( -_this.stageElem.offsetHeight / 2 ) + _this.headerHeight / 2 + 'px';

            _this.boardTiles.each( 'updateDimensions' );
            _this.snake !== undefined && _this.snake.updateDimensions();
            _this.food !== undefined && _this.food.updateDimensions();
        };

        StatePlay.prototype.createBoardTiles = function() {
            for( var y = 0; y < this.rows; y++ ) {
            for( var x = 0; x < this.cols; x++ ) {
                this.boardTiles.add( new g.BoardTile({
                parentState: this,
                parentGroup: this.boardTiles,
                col: x,
                row: y,
                x: x * this.tileWidth,
                y: y * this.tileHeight,
                w: this.tileWidth - this.spacing,
                h: this.tileHeight - this.spacing
                }));
            }
            }
        };

        StatePlay.prototype.upOn = function() { g.currentState().keys.up = 1; }
        StatePlay.prototype.downOn = function() { g.currentState().keys.down = 1; }
        StatePlay.prototype.rightOn = function() { g.currentState().keys.right = 1; }
        StatePlay.prototype.leftOn = function() { g.currentState().keys.left = 1; }
        StatePlay.prototype.upOff = function() { g.currentState().keys.up = 0; }
        StatePlay.prototype.downOff = function() { g.currentState().keys.down = 0; }
        StatePlay.prototype.rightOff = function() { g.currentState().keys.right = 0; }
        StatePlay.prototype.leftOff = function() { g.currentState().keys.left = 0; }

        StatePlay.prototype.keydown = function( e ) {
            e.preventDefault();
            var e = ( e.keyCode ? e.keyCode : e.which ),
            _this = g.currentState();
            if( e === 38 || e === 87 ) { _this.upOn(); }
            if( e === 39 || e === 68 ) { _this.rightOn(); }
            if( e === 40 || e === 83 ) { _this.downOn(); }
            if( e === 37 || e === 65 ) { _this.leftOn(); }
        };

        StatePlay.prototype.bindEvents = function() {
            var _this = g.currentState();
            window.addEventListener( 'keydown', _this.keydown, false );
            window.addEventListener( 'resize', _this.resize, false );
        };

        StatePlay.prototype.step = function() {
            this.boardTiles.each( 'update' );
            this.boardTiles.each( 'render' );
            this.snake.update();
            this.snake.render();
            this.food.update();
            this.food.render();
            this.time.update();
        };

        StatePlay.prototype.exit = function() {
            window.removeEventListener( 'keydown', this.keydown, false );
            window.removeEventListener( 'resize', this.resize, false );
            this.stageElem.innerHTML = '';
            this.grid.tiles = null;
            this.time = null;
        };

        g.addState( new StatePlay() );

        })();

        /*================================================
 Game Loop
 ================================================*/
(function(){ 'use strict';
g.config={ title:'Snakely', debug:window.location.hash=='#debug'?1:0, state:'play' };
g.setState(g.config.state);
g.time=new g.Time();
g.step=function(){
    requestAnimationFrame(g.step);
    g.states[g.state].step();
    g.time.update();
};
window.addEventListener('load',g.step,false);
})();
</script>
</body>
</html>
